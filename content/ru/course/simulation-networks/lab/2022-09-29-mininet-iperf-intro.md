---
title: "Mininet. Введение в Iperf"
author: ["Dmitry S. Kulyabov"]
date: 2022-09-29T21:11:00+03:00
lastmod: 2022-11-25T16:51:00+03:00
tags: ["network", "education"]
categories: ["computer-science"]
draft: false
weight: 202
toc: true
type: "book"
feedback: false
slug: "mininet-iperf-intro"
summary: "Введение в Iperf"
linktitle: "Введение в Iperf"
menu:
  "iperf-intro":
    parent: "simulation-networks-lab"
    weight: 202
    identifier: "iperf-intro"
---

Введение в Iperf.

<!--more-->


## <span class="section-num">1</span> Общая информация {#общая-информация}


### <span class="section-num">1.1</span> Цели {#цели}

-   Освоить основные приёмы работы с генератором трафика `iperf3`.


### <span class="section-num">1.2</span> Задачи {#задачи}

-   Подготовить лабораторный стенд.
-   В процессе интерактивного эксперимента изучить основные опции и шаблоны использования генератора трафика `iperf3`.
-   Построить графики по данным интерактивного эксперимента.
-   В процессе воспроизводимого эксперимента получить представление о создании скриптов эксперимента.
-   Построить графики по данным воспроизводимого эксперимента.


### <span class="section-num">1.3</span> Основные термины {#основные-термины}

-   Полоса пропускания (Bandwidth) --- это физическое свойство среды передачи, которое зависит от таких факторов, как конструкция и длина провода или волокна.
    -   Для сетевых инженеров пропускная способность --- это максимальная скорость передачи данных канала, величина, измеряемая в битах в секунду (бит/с)
    -   На производительность могут влиять несколько факторов, таких как задержка, потеря пакетов, джиттер и другие.
-   Пропускная способность (throughput) --- это скорость в битах в секунду, с которой процесс-отправитель может доставлять биты процессу-получателю (при связи между двумя конечными устройствами).
    -   Поскольку другие сеансы будут совместно использовать полосу пропускания по сетевому пути и поскольку эти другие сеансы будут повторяться, доступная пропускная способность может колебаться со временем
-   Иногда термины _пропускная способность_ (throughput) и _полоса пропускания_ (bandwidth) используются взаимозаменяемо.


### <span class="section-num">1.4</span> Iperf3 {#iperf3}

-   _iPerf3_ --- это инструмент для измерения пропускной способности сети в режиме реального времени.
-   Сайт: <https://iperf.fr/>.
-   Репозиторий: <https://github.com/esnet/iperf>.
-   Лицензия: 3-пунктовая лицензия BSD.
-   iPerf3 может работать с протоколами TCP, UDP и SCTP:
    -   TCP и SCTP:
        -   измерение пропускной способности;
        -   размер MSS/MTU;
        -   поддержка размера окна TCP.
    -   UDP:
        -   клиент может создавать потоки UDP с заданной пропускной способностью;
        -   измерение потери пакетов;
        -   измерение джиттера задержки;
        -   поддержка групповой рассылки (multicast).


### <span class="section-num">1.5</span> Графики по iperf3 {#графики-по-iperf3}

-   Для построения графиков по iperf3 будем использовать пакет `iperf3_plotter`.
-   Репозиторий: <https://github.com/ekfoury/iperf3_plotter>.
-   Скрипты:
    -   `preprocessor.sh`: преобразует файл JSON iPerf3 в файл значений, разделённых запятыми (CSV). Использует AWK для форматирования полей.
    -   `plot_iperf.sh`: принимает JSON-файл iPerf3, вызывает препроцессор и вызывает gnuplot для создания выходных PDF-файлов.


### <span class="section-num">1.6</span> Видео: Введение в Iperf. Введение {#видео-введение-в-iperf-dot-введение}

{{< tabs tabTotal="2" >}}
{{< rtab tabName="RuTube" >}}

{{< rutube 123f83616546c2612cc7acb9a123efae >}}

{{< /rtab >}}
{{< rtab tabName="Youtube" >}}

{{< youtube wXVasAqXlZU >}}

{{< /rtab >}}
{{< /tabs >}}


## <span class="section-num">2</span> Подготовка стенда {#подготовка-стенда}


### <span class="section-num">2.1</span> Лабораторная топология {#лабораторная-топология}

-   В топологии используется сеть 10.0.0.0/8, назначенная Mininet по умолчанию.
-   Топология представляет собой коммутатор с двумя подключёнными к нему хостами.
-   Для запуска топологии используем параметры командной строки:
    ```shell
    sudo mn --topo=single,2 -x
    ```
-   Посмотрите топологию:
    ```shell
    mininet> net
    mininet> links
    mininet> dump
    ```


### <span class="section-num">2.2</span> Рабочие файлы {#рабочие-файлы}

-   Подключимся к виртуальной машине:
    ```shell
    ssh -Y mininet@192.168.x.y
    ```
-   Для рабочих файлов будем использовать каталог `~/work/lab_iperf3`:
    ```shell
    mkdir -p ~/work/lab_iperf3
    ```


### <span class="section-num">2.3</span> Установка необходимого программного обеспечения {#установка-необходимого-программного-обеспечения}


#### <span class="section-num">2.3.1</span> Конфигурация интерфейсов виртуальной машины {#конфигурация-интерфейсов-виртуальной-машины}

-   Добавьте к виртуальной машине интерфейс NAT.
-   Загрузите виртуальную машину и войдите в учётную запись `mininet` (пароль `mininet`).
-   Добавьте в файл `/etc/netplan/01-netcfg.yaml` второй интерфейс.
-   В результате файл примет следующий вид:
    ```yaml
    network:
      version: 2
      renderer: networkd
      ethernets:
        eth0:
          dhcp4: yes
        eth1:
          dhcp4: yes
    ```
-   Перезагрузите виртуальную машину.


#### <span class="section-num">2.3.2</span> Установка iperf3 {#установка-iperf3}

-   По умолчанию стоит генератор трафика _iperf2_ (команда `iperf`).
-   Установим _iperf3_.
-   Загрузите виртуальную машину и войдите в учётную запись `mininet`:
    ```shell
    ssh -Y mininet@192.168.x.y
    ```
-   Обновим список пакетов:
    ```shell
    sudo apt-get update
    ```
-   Установите iperf3:
    ```shell
    sudo apt-get install iperf3
    ```


#### <span class="section-num">2.3.3</span> Установка скриптов для визуализации результатов {#установка-скриптов-для-визуализации-результатов}

-   Для функционирования скриптов необходимы следующие пакеты:
    -   gnuplot;
    -   jq;
    -   awk.


#### <span class="section-num">2.3.4</span> Установка `iperf3_plotter` на виртуальную машину {#установка-iperf3-plotter-на-виртуальную-машину}

-   Зайдём на виртуальную машину:
    ```shell
    ssh -Y mininet@192.168.x.y
    ```
-   Обновим репозитории программного обеспечения на виртуальной машине:
    ```shell
    sudo apt-get update
    ```
-   Установим необходимое программное обеспечение на виртуальную машину:
    ```shell
    sudo apt-get install git jq gnuplot-nox mc
    ```
-   Скачаем `iperf3_plotter`. Для этого перейдём во временную рабочую папку и скачаем репозиторий:
    ```shell
    cd /tmp
    git clone https://github.com/ekfoury/iperf3_plotter.git
    ```
-   Установим `iperf3_plotter`:
    ```shell
    cd /tmp/iperf3_plotter
    sudo cp plot_* /usr/bin
    sudo cp *.sh /usr/bin
    ```

-   Скрипты написаны плохо, не работают с путями, имеющими в названии пробелы.


#### <span class="section-num">2.3.5</span> Установка `iperf3_plotter` на локальный компьютер {#установка-iperf3-plotter-на-локальный-компьютер}

-   Установим `iperf3_plotter` (на своём компьютере). Для этого перейдём во временную рабочую папку и скачаем репозиторий:
    ```shell
    git clone https://github.com/ekfoury/iperf3_plotter.git
    ```
-   Заменим жёстко закодированные пути в файлах:
    ```shell
    cd iperf3_plotter
    sed -i -e "s:/usr/bin:~/.local/bin:g" plot_iperf.sh
    ```
-   Скопируем нужные файлы в каталог с локальными исполняемыми файлами:
    ```shell
    cp plot_* ~/.local/bin
    cp *.sh ~/.local/bin
    ```
-   Скрипты написаны плохо, не работают с путями, имеющими в названии пробелы.


### <span class="section-num">2.4</span> Видео: Введение в Iperf. Подготовка стенда {#видео-введение-в-iperf-dot-подготовка-стенда}

{{< tabs tabTotal="2" >}}
{{< rtab tabName="RuTube" >}}

{{< rutube 78670543a6ed84d93571031fb2a5c247 >}}

{{< /rtab >}}
{{< rtab tabName="Youtube" >}}

{{< youtube HkBk44OZv3c >}}

{{< /rtab >}}
{{< /tabs >}}


## <span class="section-num">3</span> Интерактивный эксперимент {#интерактивный-эксперимент}


### <span class="section-num">3.1</span> Параметры команды iperf3 {#параметры-команды-iperf3}

-   Пользователь взаимодействует с iPerf3 с помощью команды `iperf3`.
-   Основной синтаксис `iperf3`, используемый как на клиенте, так и на сервере, выглядит следующим образом:
    ```shell
    iperf3 [-s|-c] [ options ]
    ```

    -   `-s`: запуск сервера;
    -   `-c`: запуск клиента.


### <span class="section-num">3.2</span> Запуск клиента и сервера {#запуск-клиента-и-сервера}

-   Запустим `mininet`:
    ```shell
    sudo mn --topo=single,2 -x
    ```
-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s
    ```

    -   Теперь сервер прослушивает порт 5201 в ожидании входящих подключений.
-   В терминале `h1` запустите клиента:
    ```shell
    iperf3 -c 10.0.0.2
    ```

    -   Параметр `-c` указывает, что хост `h1` настроен как клиент.
    -   Параметр `10.0.0.2` --- это IP-адрес сервера (хост `h2`).
-   После завершения теста отображается сводный отчет как на клиенте, так и на сервере, содержащий следующие данные:
    -   `ID`: идентификационный номер соединения.
    -   Интервал (Interval): временной интервал для периодических отчетов о пропускной способности. По умолчанию временной интервал равен 1 секунде.
    -   Передача (Transfer): сколько данных было передано за каждый интервал времени.
    -   Пропускная способность (Bitrate): измеренная пропускная способность в каждом временном интервале.
    -   Retr: количество повторно переданных TCP-сегментов за каждый временной интервал. Это поле увеличивается, когда TCP-сегменты теряются в сети из-за перегрузки или повреждения.
    -   Cwnd: указывает размер окна перегрузки в каждом временном интервале. TCP использует эту переменную для ограничения объема данных, которые клиент TCP может отправить до получения подтверждения отправленных данных.
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.
-   Пользователь также может видеть результаты пропускной способности на стороне сервера.
-   Суммарные данные на сервере аналогичны данным на стороне клиента и должны интерпретироваться таким же образом.


### <span class="section-num">3.3</span> Запуск клиента и сервера в интерфейсе mininet {#запуск-клиента-и-сервера-в-интерфейсе-mininet}

-   Тоже самое можно выполнить и интерфейсе _mininet_
-   Запустите сервер на хосте `h2`:
    ```shell
    mininet> h2 iperf3 -s &
    ```
-   Запустите клиента на хосте `h1`:
    ```shell
    mininet> h1 iperf3 -c h2
    ```
-   Остановите серверный процесс:
    ```shell
    mininet> h2 killall iperf3
    ```


### <span class="section-num">3.4</span> Установка периода времени передачи {#установка-периода-времени-передачи}

-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s
    ```
-   В терминале `h1` запустите клиента с параметром `-t`, за которым следует количество секунд:
    ```shell
    iperf3 -c 10.0.0.2 -t 5
    ```
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.


### <span class="section-num">3.5</span> Установка временного интервала {#установка-временного-интервала}

-   Настроим клиент для выполнения теста пропускной способности с 2-секундным интервалом времени отсчёта как на клиенте, так и на сервере.
-   Опция `-i` позволяет установить интервал между отсчётами в секундах.
-   В этом случае значение должно быть установлено на 2 секунды как на клиенте, так и на сервере.
-   Параметр `-i` может быть указан по-разному на клиенте и сервере.
-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s -i 2
    ```
-   В терминале `h1` запустите клиента с параметром `-i`, за которым следует количество секунд:
    ```shell
    iperf3 -c 10.0.0.2 -i 2
    ```
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.


### <span class="section-num">3.6</span> Изменение количества байтов для передачи {#изменение-количества-байтов-для-передачи}

-   Зададим на клиенте отправку определённого объёма данных путём установки количества байтов для передачи.
-   По умолчанию _iPerf3_ выполняет измерение пропускной способности в течение 10 секунд.
-   Однако при задании количества данных клиент будет продолжать отправлять пакеты до тех пор, пока не будут отправлены все байты, указанные пользователем.
-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s
    ```
-   В терминале `h1` запустите клиента, задав объём данных:
    ```shell
    iperf3 -c 10.0.0.2 -n 16G
    ```

    -   Параметр `-n` указывает объем данных для передачи: 16 Гбайт.
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.


### <span class="section-num">3.7</span> Определение протокола транспортного уровня {#определение-протокола-транспортного-уровня}

-   По умолчанию измерения пропускной способности проводятся по протоколу TCP, который является протоколом конфигурации по умолчанию.
-   Чтобы изменить протокол на UDP, нужно задать опцию `-u` на стороне клиента.
-   Для протокола SCTP используется опция `--sctp`.
-   iPerf3 автоматически определяет протокол транспортного уровня на стороне сервера.
-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s
    ```
-   В терминале `h1` запустите клиента, задав протокол UDP:
    ```shell
    iperf3 -c 10.0.0.2 -u
    ```
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.
-   После завершения теста он покажет следующие сводные данные:
    -   ID, интервал, передача, битрейт: то же, что и у TCP.
    -   Джиттер (Jitter): разница в задержке пакетов.
    -   Lost/Total: указывает количество потерянных дейтаграмм по сравнению с общим количеством отправленных на сервер (и процентное соотношение).


### <span class="section-num">3.8</span> Изменение номера порта {#изменение-номера-порта}

-   Если нужно измерить пропускную способность определённого порта, используется параметр `-p` для настройки клиента и сервера для отправки/получения пакетов или датаграмм через указанный порт.
-   В терминале `h2` запустите сервер, используя параметр `-p`, чтобы указать порт прослушивания:
    ```shell
    iperf3 -s -p 3250
    ```
-   В терминале `h1` запустите клиента, указав порт:
    ```shell
    iperf3 -c 10.0.0.2 -p 3250
    ```
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.


### <span class="section-num">3.9</span> Работа с одним клиентом {#работа-с-одним-клиентом}

-   По умолчанию сервер iPerf3 продолжает прослушивать входящие соединения.
-   Чтобы сервер мог обрабатывать одного клиента, а затем останавливаться, к серверу добавляется параметр `-1`.
-   В терминале `h2` запустите сервер, используя параметр `-1`, чтобы принять только одного клиента:
    ```shell
    iperf3 -s -1
    ```
-   В терминале `h1` запустите клиента, указав порт:
    ```shell
    iperf3 -c 10.0.0.2
    ```
-   После завершения этого теста сервер немедленно останавливается.


### <span class="section-num">3.10</span> Экспорт результатов в файл JSON {#экспорт-результатов-в-файл-json}

-   JSON (JavaScript Object Notation, нотация объектов JavaScript) --- это облегченный формат обмена данными.
-   _iPerf3_ позволяет экспортировать результаты теста в файл JSON, что позволяет другим приложениям легко анализировать файл и интерпретировать результаты.
-   В терминале `h2` запустите сервер:
    ```shell
    iperf3 -s
    ```
-   В терминале `h1` запустите клиента, указав параметр `-J` для отображения вывода в формате JSON:
    ```shell
    iperf3 -c 10.0.0.2 -J
    ```
-   Параметр `-J` выводит текст JSON на экран через стандартный вывод (`stdout`) после завершения теста.
-   Чтобы экспортировать вывод в файл нужно перенаправить стандартный вывод в файл:
    ```shell
    iperf3 -c 10.0.0.2 -J > /home/mininet/work/lab_iperf3/iperf_results.json
    chown mininet:mininet /home/mininet/work/lab_iperf3/iperf_results.json
    ```
-   После создания файла JSON команда `ls` используется для проверки того, что файл создан.
-   Команда `cat` может использоваться для отображения содержимого файла.
-   Чтобы остановить сервер, нажмите `Ctrl+c` в терминале хоста `h2`.


### <span class="section-num">3.11</span> График результатов iPerf3 {#график-результатов-iperf3}

-   Визуализируем результаты эксперимента.
-   Скопируйте файл `iperf3_results.json` с виртуальной машины к себе, в рабочий каталог.
-   Обращайте внимание, чтобы путь к файлу не содержал пробелов.
-   Чтобы сгенерировать выходные данные для файла JSON iPerf3, выполните следующую команду:
    ```shell
    plot_iperf.sh iperf3_results.json
    ```
-   Этот сценарий создаёт графики для следующих полей:
    -   окно перегрузки (`cwnd.pdf`),
    -   повторная передача (`retransmits.pdf`),
    -   время приема-передачи (`RTT.pdf`),
    -   отклонение времени приема-передачи (`RTT_Var.pdf`),
    -   пропускная способность (`throughput.pdf`),
    -   максимальная единица передачи (`MTU.pdf`),
    -   количество переданных байтов (`bytes.pdf`).
-   Сценарий построения также создаёт файл CSV (`1.dat`), который может использоваться другими приложениями.
-   Эти файлы хранятся в каталоге результатов, созданном в том же каталоге, где был выполнен скрипт.


### <span class="section-num">3.12</span> Видео: Введение в Iperf. Интерактивный эксперимент {#видео-введение-в-iperf-dot-интерактивный-эксперимент}

{{< tabs tabTotal="2" >}}
{{< rtab tabName="RuTube" >}}

{{< rutube 70f04b82548c7ba4a03a38fce65fbcb4 >}}

{{< /rtab >}}
{{< rtab tabName="Youtube" >}}

{{< youtube REcUWuT8g8E >}}

{{< /rtab >}}
{{< /tabs >}}


## <span class="section-num">4</span> Воспроизводимый эксперимент {#воспроизводимый-эксперимент}


### <span class="section-num">4.1</span> API Mininet {#api-mininet}

-   API Mininet построен на трех основных уровнях:
    -   _Низкоуровневый API_. Низкоуровневый API состоит из базовых узлов и классов ссылок (таких как `Host`, `Switch`, `Link` и их подклассы), которые на самом деле могут быть созданы по отдельности и использоваться для создания сети, но это немного громоздко.
    -   _API среднего уровня_.  API среднего уровня добавляет объект Mininet, который служит контейнером для узлов и ссылок. Он предоставляет ряд методов (`addHost()`, `addSwitch()`, `addLink()`) для добавления узлов и ссылок в сеть, а также настройки сети, запуска и завершения работы (`start()`, `stop()`).
    -   _Высокоуровневый API_. Высокоуровневый API добавляет абстракцию шаблона топологии (класс `Topo`), который предоставляет возможность создавать повторно используемые параметризованные шаблоны топологии. Эти шаблоны можно передать команде mn (через параметр --custom) и использовать из командной строки.
-   Когда напрямую управляют узлами и коммутаторами, используется низкоуровневый API.
-   Когда запускают или останавливают сеть, используют API среднего уровня (в частности, класс `Mininet`).
-   Полные сети могут быть созданы с использованием любого из уровней API, но обычно выбирают либо API среднего уровня (например, `Mininet.add*()`), либо API высокого уровня (`Topo. add*()`) для создания сетей.


### <span class="section-num">4.2</span> Примеры создания сетей с использованием уровней API Mininet {#примеры-создания-сетей-с-использованием-уровней-api-mininet}

-   Низкоуровневый API. Узлы и ссылки:
    ```python
    h1 = Host( 'h1' )
    h2 = Host( 'h2' )
    s1 = OVSSwitch( 's1', inNamespace=False )
    c0 = Controller( 'c0', inNamespace=False )
    Link( h1, s1 )
    Link( h2, s1 )
    h1.setIP( '10.1/8' )
    h2.setIP( '10.2/8' )
    c0.start()
    s1.start( [ c0 ] )
    print( h1.cmd( 'ping -c1', h2.IP() ) )
    s1.stop()
    c0.stop()
    ```
-   API среднего уровня. Сетевой объект:
    ```python
    net = Mininet()
    h1 = net.addHost( 'h1' )
    h2 = net.addHost( 'h2' )
    s1 = net.addSwitch( 's1' )
    c0 = net.addController( 'c0' )
    net.addLink( h1, s1 )
    net.addLink( h2, s1 )
    net.start()
    print( h1.cmd( 'ping -c1', h2.IP() ) )
    CLI( net )
    net.stop()
    ```
-   API высокого уровня. Шаблоны топологии:
    ```python
    class SingleSwitchTopo( Topo ):
        "Single Switch Topology"
        def build( self, count=1 ):
    	hosts = [ self.addHost( 'h%d' % i )
    		  for i in range( 1, count + 1 ) ]
    	s1 = self.addSwitch( 's1' )
    	for h in hosts:
    	    self.addLink( h, s1 )

    net = Mininet( topo=SingleSwitchTopo( 3 ) )
    net.start()
    CLI( net )
    net.stop()
    ```
-   API среднего уровня на самом деле является самым простым и лаконичным для этого примера, поскольку не требует создания класса топологии.
-   API низкого и среднего уровня являются гибкими и мощными, но могут быть менее удобными для повторного использования по сравнению с высокоуровневым API `Topo` и шаблонами топологии.


### <span class="section-num">4.3</span> Простейшая топология {#простейшая-топология}

-   На основе скрипта `mininet/examples/emptynet.py` создадим простейшую топологию `lab_iperf3_topo`:
    ```python
    #!/usr/bin/env python

    """
    Simple topology
    """

    from mininet.net import Mininet
    from mininet.node import Controller
    from mininet.cli import CLI
    from mininet.log import setLogLevel, info

    def emptyNet():

        "Create an empty network and add nodes to it."

        net = Mininet( controller=Controller, waitConnected=True )

        info( '*** Adding controller\n' )
        net.addController( 'c0' )

        info( '*** Adding hosts\n' )
        h1 = net.addHost( 'h1', ip='10.0.0.1' )
        h2 = net.addHost( 'h2', ip='10.0.0.2' )

        info( '*** Adding switch\n' )
        s1 = net.addSwitch( 's1' )

        info( '*** Creating links\n' )
        net.addLink( h1, s1 )
        net.addLink( h2, s1 )

        info( '*** Starting network\n')
        net.start()

        info( '*** Running CLI\n' )
        CLI( net )

        info( '*** Stopping network' )
        net.stop()


    if __name__ == '__main__':
        setLogLevel( 'info' )
        emptyNet()
    ```

-   Основные элементы:
    -   `addSwitch()`: добавляет коммутатор в топологию и возвращает имя коммутатора;
    -   `ddHost()`: добавляет хост в топологию и возвращает имя хоста;
    -   `addLink()`: добавляет двунаправленную ссылку в топологию (и возвращает ключ ссылки, но это не важно). Ссылки в Mininet являются двунаправленными, если не указано иное.
    -   `Mininet`: основной класс для создания и управления сетью;
    -   `start()`: запускает вашу сеть;
    -   `pingAll()`: проверяет подключение, пытаясь заставить все узлы пинговать друг друга;
    -   `stop()`: останавливает вашу сеть;
    -   `net.hosts`: все хосты в сети;
    -   `dumpNodeConnections()`: сбрасывает подключения к/от набора узлов;
    -   `setLogLevel( 'info' | 'debug' | 'output' )`: установить уровень вывода Mininet по умолчанию; рекомендуется `info`.
-   Создадим в лабораторной работе подкаталог для данного эксперимента:
    ```shell
    mkdir -p ~/work/lab_iperf3/iperf3_topo
    ```
-   Скопируем скрипт на виртуальную машину в каталог лабораторной и запустим:
    ```shell
    sudo python lab_iperf3_topo.py
    ```
-   После запуска можно посмотреть элементы топологии:
    ```shell
    mininet> net
    mininet> links
    mininet> dump
    ```


### <span class="section-num">4.4</span> Методы настройки хоста {#методы-настройки-хоста}

-   Хосты Mininet предоставляют ряд удобных методов настройки сети:
    -   `IP()`: возвращает IP-адрес хоста или определенного интерфейса;
    -   `MAC()`: возвращает MAC-адрес хоста или определенного интерфейса;
    -   `setARP()`: добавить статическую запись ARP в кэш ARP хоста;
    -   `setIP()`: установить IP-адрес для хоста или определенного интерфейса;
    -   `setMAC()`: установить MAC-адрес для хоста или определенного интерфейса.
-   Пример использования в скрипте:
    ```python
    print( "Host", h1.name, "has IP address", h1.IP(), "and MAC address", h1.MAC() )
    ```
-   Задание: Попробуйте изменить приведённый выше код, чтобы он печатал IP-адрес и MAC-адрес каждого хоста.


### <span class="section-num">4.5</span> Настройка параметров производительности {#настройка-параметров-производительности}

-   Mininet предоставляет функции ограничения производительности и изоляции с помощью классов `CPULimitedHost` и `TCLink`:
    ```python
    from mininet.node import CPULimitedHost
    from mininet.link import TCLink
    ...
    net = Mininet( controller=Controller, host = CPULimitedHost, link = TCLink )
    ```

-   Основные функции:
    -   `self.addHost(name, cpu=f)`: позволяет указать долю общих ресурсов процессора системы, которая будет выделена виртуальному хосту;
    -   `self.addLink(node1, node2, bw=10, delay='5ms', max_queue_size=1000, loss=10, use_htb=True)`: добавляет двунаправленный канал с характеристиками пропускной способности, задержки и потерь:
        -   максимальный размер очереди 1000 пакетов;
        -   использование ограничителя скорости _Hierarchical Token Bucket_;
        -   эмулятор задержки/потери `netem`;
        -   параметр `bw` выражается числом в Мбит;
        -   задержка выражается в виде строки с заданными единицами измерения (например, `5ms`, `100us`, `1s`);
        -   потери выражаются в процентах (от 0 до 100);
        -   `max_queue_size` выражается в пакетах.
-   Задание: Измените приведённый выше код, чтобы каналы были 100 Мбит/с с задержкой 75 мс. Рассчитать производительность связи между `h1` и `h2`.


### <span class="section-num">4.6</span> Полный эксперимент {#полный-эксперимент}

-   Сгенерируем трафик и сохраним результат в файл json.
-   Зададим скрипт `lab_iperf3.py` для полного эксперимента:
    ```python
    #!/usr/bin/env python

    """
    Simple experiment.
    Output: iperf_result.json
    """

    from mininet.net import Mininet
    from mininet.node import Controller
    from mininet.cli import CLI
    from mininet.log import setLogLevel, info
    from mininet.link import TCLink
    import time

    def emptyNet():

        "Create an empty network and add nodes to it."

        net = Mininet( controller=Controller, waitConnected=True, link = TCLink )

        info( '*** Adding controller\n' )
        net.addController( 'c0' )

        info( '*** Adding hosts\n' )
        h1 = net.addHost( 'h1', ip='10.0.0.1' )
        h2 = net.addHost( 'h2', ip='10.0.0.2' )

        info( '*** Adding switch\n' )
        s1 = net.addSwitch( 's1' )

        info( '*** Creating links\n' )
        net.addLink( h1, s1, cls=TCLink, bw=100, delay='75ms' )
        net.addLink( h2, s1, cls=TCLink, bw=100, delay='75ms' )

        info( '*** Starting network\n')
        net.start()

        info( '*** Traffic generation\n')
        h2.cmdPrint( 'iperf3 -s -D -1' )
        time.sleep(10)  # Wait 10 seconds for servers to start
        h1.cmdPrint( 'iperf3 -c', h2.IP(), '-J > iperf_result.json' )

        info( '*** Stopping network' )
        net.stop()

    if __name__ == '__main__':
        setLogLevel( 'info' )
        emptyNet()
    ```
-   Создадим в лабораторной работе подкаталог для данного эксперимента:
    ```shell
    mkdir -p ~/work/lab_iperf3/iperf3
    ```
-   Запустите скрипт на виртуальной машине:
    ```shell
    sudo python lab_iperf3.py
    ```
-   Постройм графики из получившегося файла json:
    ```shell
    plot_iperf.sh iperf_result.json
    ```
-   Создадим `Makefile` для проведения всего эксперимента:
    ```makefile
    all: iperf_result.json plot

    iperf_result.json:
    	sudo python lab_iperf3.py

    plot: iperf_result.json
    	plot_iperf.sh iperf_result.json

    clean:
    	-rm -f *.json *.csv
    	-rm -rf results
    ```


### <span class="section-num">4.7</span> Видео: Введение в Iperf. Воспроизводимый эксперимент {#видео-введение-в-iperf-dot-воспроизводимый-эксперимент}

{{< tabs tabTotal="2" >}}
{{< rtab tabName="RuTube" >}}

{{< rutube c54df490dcdaba3f0e78ab078148a519 >}}

{{< /rtab >}}
{{< rtab tabName="Youtube" >}}

{{< youtube wpPDMyZbcGU >}}

{{< /rtab >}}
{{< /tabs >}}
